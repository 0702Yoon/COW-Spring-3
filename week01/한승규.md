# Week1

작업자: 승규 한
상태: 진행 중
요약: Week1
마감일: 2024년 3월 24일

## **자바 역사와 버전별 특징**

### 자바 역사

자바는 1995년 Sun Microsystems에 의해 개발된 객체지향 프로그래밍 언어다. 자바는 한 번 작성하면 어디서든 실행될 수 있다는 이념으로 다양한 플랫폼에서 호환성을 유지할 수 있다는 특징을 가지고 있다.

### 버전별 특징

- 자바 1.0 (1996) 최초의 자바 버전으로 객체 지향 프로그래밍의 기반을 마련하고 애플릿을 통해 간단한 웹 애플리케이션을 개발할 수 있는 기능을 제공하였다.

- 자바 1.1 (1997) JDBC, 이너 클래스, JavaBeans 등의 기능을 추가하였고 Reflection API와 Object Serialization을 지원했다.

- 자바 1.2 (1998) Swing API가 추가되었고 Collections 프레임워크 도입하였다. JVM의 JIT 컴파일러가 추가된 버전이다.

- 자바 1.3 (2000) HotSpot JVM이 도입되고 Java Sound, JNDI 등의 기능이 추가되었다.

- 자바 1.4 (2002): assert 키워드가 추가되고 정규식 기능이 추가되었다.

- 자바 5 (2004): 제네릭, enum, 어노테이션, 가변 인수 기능을 도입하여 프로그래밍 편의성 및 안정성 향상시켰다.

- 자바 1.6 (2006) 웹서비스를 개선하고 스크트 언어를 지원하며 JDBC 4.0의 기능을 추가하였다.

 

- 자바 1.7 (2011) switch문, try-catch문이 추가되었다.

- **자바 8** (2014) 자바에서 핵심적인 버전인 자바 8은 람다 표현식과 함수형 인터페이스를 도입하고 스트림 API를 추가하였다.

- 자바 9 (2017) 모듈 시스템(JPMS) 도입으로 애플리케이션 모듈화를 지원하게 되었다.

- 자바 10 (2018) 지역변수 타입 추론을 위한 var 키워드를 도입하였으며 가비지 컬렉터를 개선하였다.

- 자바 11 (2018) 인터페이스 private 메서드 지원과 Open JDK Oracle JDK 통합하였다.

- 자바 12 (2019) 새로운 switch문을 추가하고 JVM 메모리 관리를 개선했다.

- 자바 13 (2019) 텍스트 블록을 추가하고 동적 CDS 아카이브를 지원한다.

- 자바 14 (2020) 새로운 switch문을 표준으로 결정하였다.

- 자바 15 (2020) sealed classes와 패턴 매칭 등의 기능을 추가하였다.

- 자바 16  (2021)  Unix 도메인 소켓 연결을 지원하였다.

- 자바 17 (2021): 세이브포인트 폴링을 제거하고 패턴 매칭 등의 기능을 통해 개발 편의성과 성능을 개선하였다.

---

## **Primitive Type과 Reference Type의 차이점**

`Primitive Type`(원시 타입) - Primitive Type은 자바에서 사전에 정의해놓은 기본 데이터 타입으로, 변수에 실제 데이터 값을 저장한다. 이들의 크기와 동작 방식은 임의로 변경할 수 없고 data 형식은 정수, 실수, 문자, 논리 리터럴의 데이터 형식을 포함한다.

byte, short, int, long, float, double, char, boolean이 원시 타입에 해당한다

`Reference Type`(참조 타입) - Reference Type은 객체를 참조하는 타입이다. Reference 변수는 실제 데이터가 아닌 힙 영역에 할당되어있는 데이터의 메모리 주소값이 담긴다. 프로그램은 변수에 담긴 주소를 통해 실제 객체에 접근할 수 있다. 참조 타입 변수에 담긴 값은 실제 데이터가 아니기때문에 참조 타입 간의 연산은 메모리 주소의 복사와 비교로 이루어진다. 

Class, Interface, Array 등이 참조타입에 해당한다.

---

## **JAVA의 접근 제어자**

접근 제어자에는 private, default, protected, public이 있다.

- `private`은 클래스 내부 접근 이외의 모든 외부 호출을 막는다. private을 통해 내부 구현을 캡슐화 할 수 있다.
- `default`는 접근제어자를 명시하지 않았을 때 기본적으로 적용되는 접근제어자다. 같은 패키지 안의 클래스에 한하여 접근을 허용한다.
- `protected`는 같은 패키지 내의 호출과 상속 관계의 경우 호출을 허용한다. protected를 통해 부모 클래스의 특정 필드나 메서드에 서브 클래스가 접근할 수 있다.
- `public`은 모든 클래스 접근을 허용한다. 외부에서 사용될 기능에 주로 public을 사용한다.

각각의 접근제어자는 목적에 따른 사용법이 다르므로 적절한 접근제어자를 사용함으로 더 나은 클래스 설계를 할 수 있다.

---

## **static 키워드**

자바의 `static` 키워드는 변수, 메서드, 초기화 블록에서 사용된다.

1. 변수에 static이 붙는 경우 클래스 변수라고 불린다. 클래스 변수는 객체에 속하지 않고 클래스에 속하며 클래스의 모든 객체가 이 변수를 공유한다 

1. 메서드에 static이 붙는 경우 클래스 메서드라고 불린다. 클래스 메서드 또한 객체에 속하지 않고 클래스에 속한다. 클래스 메서드는 클래스 인스턴스가 없이 호출될 수 있으므로 static이 아닌 필드에는 접근할 수 없다.

1. static 초기화 블록은 JVM이 로드될 때 한 번만 실행되는 것으로 static 필드를 초기화 할 수 있고 복잡한 초기화 로직이 필요할떄 사용된다.

---

## **final 키워드**

자바의 `final` 키워드는 변수, 메서드 클래스에서 사용된다.

1. 변수에 final이 붙는 경우는 변수에 담긴 값을 변경할 수 없다. 원시타입의 경우에는 변수의 데이터 자체를 변경할 수 없고 참조 타입의 경우에는 변수의 참조 값을 바꿀 수 없다. 하지만 참조 값이 가리키는 힙 영역의 데이터 값은 변경할 수 있다.

1. 메서드에 final이 붙는 경우 Overriding이 불가능하다 부모의 메서드를 자식이 재정의 하지 못하게 할 때 final을 한다.

1. 클래스에 final이 붙는 경우 상속될 수 없다. 변경되면 안 되는 클래스의 보안을 강화할 때 사용된다.

final 키워드를 통해 프로그램의 안정성과 불변성을 강화시킬 수 있다.

---

## **오버로딩(Overloading)과 오버라이딩(Overriding)**

Overloading과 Overriding은 다형성을 구현하는 두 가지 방법이다.

- `Overloading`은 같은 이름을 가진 메서드가 서로 다른 매개변수 타입, 순서, 개수를 가지는 것을 말한다.
    
    Overloading을 통해 입력 데이터의 유형이나 개수가 다를 때 유연성을 제공한다.
    
    Overloading 메서드는 메서드를 호출할 때 어떤 메서드를 사용할지 컴파일 시간에 결정한다. 이를 정적 다형성이라고 한다.
    

- `Overriding`은 상속관계 클래스에서 하위 클래스가 메서드를 상속받을 때 메서드를 재정의하는 것을 Overriding이라고 한다.
    
    Overriding을 통해 상속받은 메서드의 동작을 변경하여 같은 메서드 호출에 대해 다른 행위를 수행할 수 있도록 함으로써 코드 재사용성과 유지보수를 용이하게 한다.
    
    Overriding은 객체의 실제 타입을 기반으로 하기에 런타임 시점에 해당 객체의 메서드가 호출된다.
    

---

## **추상 클래스와 인터페이스**

`추상 클래스`는 생성자를 포함할 수 있으며 extends를 사용한다. 추상 클래스는 구현 메서드와 추상 메서드를 모두 포함할 수 있으며 다중 상속이 불가능하다는 특징을 가진다.

다중 상속이 불가능한 이유는  A 클래스를 B, C 클래스가 상속받고 D 클래스가 B, C 클래스를 상속받을 시 B, C가  같은 이름을 가진 메서드를 구현하고 있으면 B, C 중 어떤 메서드를 사용해야할지 명확하지 않기 때문이다. 이를 다이아몬드 문제라고 한다. 

`인터페이스`는 생성자를 포함할 수 없고 추상 메서드만 존재할 수 있으므로 다이아몬드 문제가 발생할 수 없어 implements로 다중 상속이 가능하다.

- 자바 8부터는 인터페이스에도 default, static으로 구현한 메서드를 포함할 수 있다.  → default method를 통해 발생하는 다이아몬드 문제는 Override를 필수조건으로 넣어 해결했다.

추상 클래스와 인터페이스는 다형성의 핵심적인 역할을 한다.

---

## **JAVA Enum**

enum은 열거형으로 고정된 상수들의 집합을 정의하는 데 사용되는 특별한 타입의 클래스다. 여기서 상수는 고정된 값을 의미한다.

```jsx
public enum Role {
WEB, SERVER, APP, MANAGER
}
```

위와 같은 방식으로 enum을 선언할 수 있다.

장점

- enum을 사용하면 예상 값 중 하나만 가질 수 있으므로 코드의 안정성이 향상된다
- 숫자나 문자열 상수 대신 enum을 사용함으로 코드의 의도를 보다 명확하게 전달할 수 있다.
- 메서드, 필드, 생성자를 포함하고 인터페이스를 구현할 수 있어 단순 상수 집합 이상의 기능을 제공한다.

---

## **객체지향**

### 객체지향

객체지향은 소프트웨어 개발에서 사용되는 프로그래밍 설계 패러다임 중 하나다. 객체지향이 적용된 소프트웨어 개발 방식은 현실 세계의 객체를 모델링하여 소프트웨어를 개발하는 방식으로 진행된다.

### 객체지향 프로그래밍

객체지향 프로그래밍(OOP)은 코드와 데이터를 객체 단위로 분리해서 이들의 상호작용으로 프로그램을 작성하는 프로그래밍 기법이다. 이는 절차적 프로그래밍과 다르게 행위가 아닌 명사에 초점을 맞춰 프로그래밍을 하게 된다.

객체지향 프로그래밍은 실제 세계의 사물을 객체를 표현하기때문에 프로그램을 이해하고 디버그하기 쉽게 만들어 준다는 장점이 있다.

### 객체지향 프로그래밍 핵심 개념

- **책임** - 모든 객체는 자신만의 책임을 가진다. 자바에서 이러한 책임을 수행하는 데 필요한 행위는 메서드를 통해 구현된다. 객체의 책임은 그 객체가 수행하는 모든 작업을 말하며 이는 곧 객체 존재 목적의 정의다.

- 역할 - 역할은 책임들의 집합으로 볼 수 있다. 다양한 객체들 중 몇몇은 서로 동일한 역할을 수행할 수 있고 이는 객체 간의 대체 가능성을 의미한다. 객체간의 대체 가능성을 통해 유연성과 재사용성을 높일 수 있다.

- 협력 - 객체지향 프로그래밍에서 협력은 객체간의 메세지 전달을 통해 각각 자신의 책임을 수행하는 일련의 과정을 말한다. 협력을 통해 궁극적으로 시스템의 전체 기능을 구현할 수 있다.

### 객체지향과 JAVA

JAVA는 클래스 기반의 객체지향 프로그래밍 언어다. 객체지향 언어인 JAVA를 통해 상속, 추상화, 다형성, 캡슐화와 같은 특성을 활용하며 코드의 재사용성, 유지보수성, 확장성을 향상시킬 수 있다.

### Spring과 객체지향

Spring은 자바 기반의 애플리케이션 개발을 위한 툴킷을 제공하는 프레임워크다. 스프링 프레임워크는 객체지향 설계 원칙을 보다 효율적으로 구현하고 적용할 수 있는 다양한 기능들을 제공한다. Spring은 기본적으로 객체지향 핵심원칙인 상속, 추상화, 다형성을 통해 유연성과 재사용성을 가능하게 한다.

Spring에서 지원하는 객체지향적 설계 기능들은 대표적으로 의존성 주입과 AOP가 있다.

DI(Dependency Injection)

DI는 의존성 주입으로 객체간의 의존성을 외부에서 결정하고 주입함으로써 구성 요소 간의 결합도를 낮추고 자신의 책임에 집중할 수 있게 해준다. 의존성을 외부에서 주입함으로써 코드의 재사용성과 의존성 변경이 보다 간단해진다.

AOP(Aspect-Oriented Programming)

AOP는 프로그램의 공통 관심사를 분리하여 모듈로 정의하고 적용시키는 방식이다. 여기서 말하는 공통된 관심사란 보안, 로깅, 트렌젝션 관리와 같은 공통적인 기능들을 말하며 핵심 로직으로부터 공통기능들을 분리하여 관리할 수 있게 해준다.

 AOP를 통해 코드의 가독성과 재사용성을 높이고 유지보수성을 향상시킬 수 있다.

---

## **객체지향 4대 특성**

`추상화` - 추상화는 복잡한 현실 세계의 공통된 특징을 뽑아 하나로 정의하는 것을 말한다. 자바에서는 추상화를 통해 클래스들의 공통되는 속성과 기능을 추상 클래스나 인터페이스로 정의하여 객체 간의 관계를 효과적으로 설정하고 유지 보수를 용이하게 한다. 

추상화를 통해 개발자는 복잡성을 관리하고 시스템의 핵심적인 부분에 집중할 수 있다.

`다형성` - 다형성은 같은 이름의 메서드가 여러 다른 행위를 할 수 있는 성질을 말한다. 자바에서는 Overriding과 Overloading, 인터페이스와 추상 클래스를 통해 다형성을 실현할 수 있다. 

다형성을 통해 개발자는 유연하고 확장 가능한 코드를 작성할 수 있고 코드의 재사용성을 높일 수 있다.

`상속` - 상속은 한 클래스가 다른 클래스의 메서드와 변수를 이어받을 수 있게 해주는 것이다. 상속을 통해서 공통적인 기능을 부모 클래스에서 정의하고, 자식 클래스에서 이를 확장/변경할 수 있다. 

상속을 통해 코드의 중복을 줄이고 재사용성과 유지 보수성을 향상시킬 수 있다.

`캡슐화` - 캡슐화는 데이터와 메서드를 하나의 단위로 묶어 객체의 세부 구현을 숨기고 사용자에게 객체의 기능만 이용할 수 있게 하는 객체지향 프로그래밍 기법이다. 객체의 내부 구현을 변경하더라도 외부에 노출된 인터페이스가 유지되면 객체 사용 코드를 변경하지 않아도 된다.

---

## **SOLID 원칙**

`SRP`(단일 책임 원칙)

하나의 클래스가 사용자 정보를 저장하기도 하고 데이터베이스 관리 코드를 가지고 있는 것과 같이 두 가지의 변경의 이유를 가지는 경우 단일 책임 원칙 위반이다.

→ 하나의 클래스는 하나의 책임만 가져야 한다.

`OCP` (개방 폐쇄 원칙)

새로운 결제 방법을 추가할 때마다 기존 코드를 변경하지 않고 시스템의 확장이 가능하도록 해야 하는 것을 개방 폐쇄 원칙이라고 한다.

→ 확장에는 열려있고 수정에는 닫혀 있어야 한다.

`LSP`(리스코프 치환 법칙)

상위 타입의 객체를 하위 타입의 객체가 대신하더라도 상위 타입을 사용하는 프로그램은 정상적으로 작동해 프로그램의 정확성을 깨뜨리지 않게 한다는 것이 LSP 원칙이다.

`ISP` (인터페이스 분리 원칙)

상속받는 클래스가 사용하지 않는 기능을 가지지 않게 구체화하여 인터페이스를 분리해야 한다.

→ 상속받는 클래스 자신이 사용하지 않는 인터페이스를 구현하지 않아야 한다. 

`DIP`(의존성 역전 원칙)

클라이언트가 상속관계 모듈을 가져와 사용할 때 하위 모듈을 직접 인스턴스로 사용하지 않고 상위 모듈인 인터페이스에 의존해야 한다.

→ 고수준의 모듈이 저수준 모듈의 구현이 아닌 추상화에 의존해야 한다.

---

## **Java Annotation**

Java Annotation은 자바 5부터 도입된 개념으로 JDK가 지원하는 자바의 기본 기능이다. 

Annotation을 사용함으로써 코드의 작동 방식 정보를 제공하는 메타데이터를 추가할 수 있게 되었다. 개발자는 자바 어노테이션을 통해 코드 분석, 컴파일 타임 및 런타임 처리를 할 수있게 되었다. 

사용자 정의 어노테이션을 제외한 어노테이션은 기본 어노테이션과 메타 어노테이션으로 나뉜다.

- 기본 어노테이션은 java.lang 패키지에 포함된 어노테이션으로 코드 가독성을 높이고 오류 가능성을 줄여 개발자의 의도를 명확하게 전달할 수 있게 해준다.
- 메타 어노테이션은 java.lang.annotation 패키지에 포함 되어있다. 메타 어노테이션을 통해 어노테이션의 동작 방식을 지정할 수 있다.

---

## **Lambda, Stream**

`Lamda` 표현식은 자바 8에 도입된 개념으로 객체지향 프로그래밍 언어인 자바에서 함수형 프로그래밍 패러다임의 일부를 통합하는 역할을 한다.

기존 자바는 클래스 기반으로 모든 메서드가 클래스에 종속적으로 존재했다. 하지만 람다 표현식을 통해 개발자는 메서드를 함수 형식으로 매개변수 타입을 명시적으로 선언하지 않고 더욱 간결하게 표현 클래스로부터 독립적인 함수로서의 기능을 구현할 수 있게 되었다. 

이를 통해 자바에서 함수를 변수에 할당하거나 다른 함수의 인자로 전달하고 함수에서 반환할 수 있게 되었다.

람다는 단독으로 존재할 수 없고 함수형 인터페이스를 통해 사용된다. 함수형 인터페이스는 하나의 추상메서드를 갖는 인터페이스(default, static 메서드는 가질 수 있음)로 람다는 이 추상 메서드의 구현체로 동작한다. 자바에서는 `@FunctionalInterface` 어노테이션을 통해 함수형 인터페이스를 명확하게 해준다.

람다가 코드에서 사용되면 컴파일러가 함수형 인터페이스의 익명 구현체로 변환해 준다 이 과정은 컴파일러단에서 자동으로 이루어진다. 

람다를 통해 개발자들은 간결한 코드를 작성할 수 있게 되었다.

```jsx

//람다 사용 전
int max(int a, int b){ 
return a > b ? a : b;
}

//람다 사용 후
retrun (a, b) -> a > b ? a : b;
```

`Stream`은 자바 8 도입된 핵심 추상 개념으로 컬렉션 처리를 위한 API다. Stream을 사용하면 for문과 iterateor를 사용하지 않고 데이터를 추상화된 연속적인 흐름으로 처리할 수 있게 해준다. Stream API는 병렬 스트림을 통한 병렬 처리로 복잡한 데이터 처리 작업을 간결하고 직관적으로 수행할 수 있게 해준다.

Stream을 사용하여 데이터를 어떻게 처리할지만 작성하면 데이터 소스의 구체적인 구현 방식은 신경 쓰지 않고 수행에 대한 부분은 Stream 라이브러리가 담당해 주어 코드의 가독성과 유지 보수성을 향상시켜준다. 이때 원본 데이터 값을 변하지 않는다.

Stream은 중간 연산과 최종 연산으로 구분된다. 

중간 연산은 리스트에서 조건에 따른 값을 골라내는 필터링, 조건에 맞는 값을 처리해 주는 매핑과 같 연산을 수행한다. 이때 데이터가 바로 처리되는 것이 아니라 계획을 세우는 단계(지연평가)라고 생각하면 된다.

최종 연산은 단계에서는 실제 데이터 처리를 담당하고 그 결과를 얻어낸다. 즉 중간 연산으로 데이터 처리에 대한 계획을 세우면 실제 계획을 실행하는 것은 최종 연산이 담당하는 것이다.

Stream을 통해 개발자는 더욱 간결한 코드로 복잡한 과정을 처리할 수 있게 되었다.

---

## JVM 내부 구조 & 메모리 영역

- JVM은 컴파일러를 통해 byte code로 변환된 파일을 Class Loader를 통해 필요한 실행 시점마다 메모리에 할당해 준다.

- JVM은 내부에서 바이트 코드가 올바른 포맷을 가지고 있는지 검증 → 클래스 또는 인터페이스에 필요한 메모리를 할당하고 필드를 기본값으로 초기화하는 리소스 준비 → 바이트 코드 내의 메모리 참조를 실제 메모리 참조로 변환하는 해석의 과정을 거친다.

- 현대의 JVM 실행 엔진은  `JIT Compiler` 와  `Interpreter`를 조합해서 사용한다.
    
    `JIT Compiler` 는 자주 실행되는 코드 부분을 기계어로 변환하여 실행 속도를 개선한다는 장점이 있다.
    
    `Interpreter`는  바이트 코드를 기계어로 컴파일하지 않아 시작 시간이 상대적으로 짧고 JIT을 통해 번역된 기계어 코드는 추가적인 메모리를 사용하기 때문에 메모리 효율에서 장점을 가진다.
    
    이러한 이유로 JVM은 두 가지의 조합으로 byte code를 기계어로 변환시켜주어 자바 코드가 OS에 종속 받지 않고 동작할 수 있게 해준다. 
    
- JVM은 스레드를 효율적으로 관리하고 실행하는 스레드 스케줄링, 공유 자원 접근을 제어하여 데이터 일관성을 유지하고 스레드 간의 충돌을 방지하는 동기화, 힙 영역과 각 스레드의 스택 영역 관리를 통해 여러 작업을 동시에 처리할 수 있는 멀티스레딩 기능을 지원한다.

- JVM은 프로그램 실행 중 오류가 발생하면 해당 오류 객체를 생성한다. 그 후 호출 스택을 따라 올라가면 catch 블록을 찾고 예외를 처리한다. 만약 처리자를 찾지 못하면 프로그램을 종료한다.

- JVM은 GC(Garbage Collector**)**를 통해 힙 영역에 사용되지 않는 인스턴스를 제거하여 자동으로 메모리를 관리해 준다.

자바에서 메모리 구조는 대표적으로 메서드 영역, 스택 영역, 힙 영역이 존재한다.

- `메서드 영역`은 클래스구조, 정적변수, 상수, 메서드 데이터가 저장된다. 여기서 메서드는 메서드의 실행 코드 자체(byte code)를 말한다.

- `스택 영역`은 메서드호출과 지역변수를 관리한다. 즉 지역변수, 매개변수, 리턴 주소가 스택영역에 할당되고 스레드를 통해 관리된다.

- `힙 영역`은 new로 생성된 모든 객체의 실제 데이터와 동적으로 생성된 배열이 저장되고 GC를 통해 관리된다.