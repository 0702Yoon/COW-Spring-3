# [1WEEK] JAVA 기본

## COW SPRING 3기 PRE-ONBOARDING 학습 과제

본격적으로 Spring 학습에 들어가기 전에 여러분은 객체지향 코드에 대해 학습하고 이해하는 시간을 가지실겁니다!

객체지향 코드를 짜기 위해서는 우리가 사용할 언어인 JAVA에 대해 이해하고 있어야합니다. 

이 온보딩 과제는 이번 COW L2 - Spring에 함께 하시는 9분의 개개인의 역량이 다르기 때문에 가장 최소한으로 알고 계셔야 할 내용을 중심으로 선정해봤어요!

많은 양의 정리를 요구하지 않는 과제이니 이해하신 내용을 토대로 간단하게 정리해주시면 됩니다. (1, 2기의 학습자료가 github에 나와있으니 참고하셔도 좋아요☺️)

개인적으로, 분명 학습했던걸 다 기억하실 수 없으실거예요! 저도 마찬가지이고요.. 공부했던 것을 잘 정리해두는 습관을 가지는 것은 분명 큰 도움으로 돌아올 것이라 생각합니다. 그런 의미로 다들 파이팅해봐요!

---
> 아래의 필수 질문은 모든 분들이 정리하고 학습하셔야하는 내용입니다. 선택 질문은 원하시는 분들만 하시면 되지만 분명 학습하시면 큰 도움이 될 것들을 추려봤습니다! 

# 필수

## 자바 역사와 버전별 특징

---
 자바는 1995년에 선 마이크로시스템즈에 의해 공식적으로 발표된 객체 지향 프로그래밍 언어입니다. 
 자바는 '한 번 작성하면 어디서나 실행된다'는 슬로건 아래, 다양한 플랫폼에서 실행될 수 있는 특징을 가지고 있습니다. 이러한 특징을 플랫폼 독립성이라고 합니다.
 자바의 역사로는 자바 8 부터 람다 표현식, 스트림 api (컬렉션 처리를 위한 새로운 api), 날짜 시간 api와 같은 기능을 구현했습니다.
 자바 9부터는 모듈시스템과 jshell(자바 코드 조각을 대화식으로 실행할수 있게하는 도구)를 지원했고
 자바 10부터는 var 키워드, 병렬 처리 가비지 컬렉션을 도입하여 성능을 향상했고 jvm 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당이 가능하게 하였습니다.또한 자바 10부터 자바 소스 파일을 먼저 컴파일 하지 않고도 실행 할 수 있는 스크립팅을 향한 첫 걸음이라고 할 수 있습니다.
 자바 11부터는 http 클라이언트 api를 지원하기 시작했고, 자바 10에서 나왔던 var 키워드를 확장하였습니다. 
 자바 12, 13 은 그 이전과 그릐 바뀐것이 많지 않습니다.
 자바 14는 스위치 표현식이 표준화 되었으니면 instanceof 패턴매칭, record 선언 기능이 추가되었습니다. 자바 15에서는 문자열 다루기 기능이 추가 되었으며 스케일링 가능한 낮으느 지연의 가비지 컬렉터가 추가되었습니다.  자바 16에서는 foreign linker api과 unix 도메인 소켓에 연결할 수 있는 기능이 추가되었습니다.
 자바 17에서는 자바 11이후의 새로운 자바 장기 지원이 나왔습니다. 객체를 전달하여 기능을 전환하고 특정 유형을 확인 할 수 있게 되었습니다. 또한 패턴 매칭(switch 문)와 클래스의 상속을 제한할 수 있는 sealed 클래스를 지원했습니다.
 마지막으로 자바 19에는 경량 스레드를 지원하여 동시성 프로그래밍을 간소화하는 가상 스레드가 나왔고 외부 함수와 메모리에 접근 할 수 있는 새로운 api 또한 등장했습니다.

 
 

## Primitive Type과 Reference Type의 차이점

---자바에서는 데이터 타입을 저 두가지 타입으로 나누는데, 원시 타입(primitive type)은 자바에서 미리 정의된 8가지 기본 타입으로, 실제 값을 메모리에 직접 저장한다는 특징이 있습니다. 예를 들어 int, double, boolean등과 같은 타입입니다. 이 값은 스택 메모리에 직접 저장되며 null 값을 가질 수 없습니다. 
 한편 참조 타입(reference type)은 원시 타입을 제외한 모든 타입으로 객체의 주소를 저장합니다. 이는 String, list, class와 같은 타입이며 객체가 힙 메모리에 저장되며 변수는 이 객체의 주소를 스택 메모리 에 저장한다는 특징이 있습니다. 이 값은 null값을 가질 수 있어 아무것도 참조하지 않는 상태를 나타낼 수 있습니다.

## JAVA의 접근 제어자

---자바에서 접근 제어자는 변수등의 멤버에 대한 접근 권한을 제어하는 역할을 합니다. 
 먼저 public 같은 경우, 어떤 클래스에든 접근이 가능한 가장 넓은 범위를 가지고 있습니다.
  protected는 같은 패키지 내부 또는 다른 패키지의 자식 클래스에서 접근 할 수가 있으며,
  default 즉 기본 접근 제어자는 접근 제어자를 명시하지 않으면 같은 패키지 내에서만 접근이 가능합니다. 마지막으로 private은 선언된 클래스 내부에서만 접근이 가능합니다. 가장 제한적인 좁은 범위의 접근만을 허용합니다.


## static 키워드

---static 키워드는 클래스의 멤버 (변수, 메소드)를 클래스에 속하게 만들어, 객체 생성 없이 사용할수 있게 하는 키워드입니다. 모든 인스터스가 공통적으로 사용해야 하는 값에 static을 붙이며 해당 변수는 모든 인스턴스에 의해 공유됩니다. static으로 선언된 멤버는 프로그램이 시작할 때 메모리에 할당되고 이는 메모를 효율적으로 사용 할 수 있게 해줍니다. static은 변수 뿐만 아니라 메서드에도 사용 가능하며 블록에도 사용이 가능할만큼 넓게 사용가능하지만, 너무 많이 사용하면 메모를 많이 차지 하기에 사용량이 과도하게 많아지면 좋지 않으며 객체지향 프로그래밍 원칙과 좀 벗어나는 단점 또한 존재합니다.


## final 키워드

---final 키워드는 변수, 메서드, 클래스에 사용 될 수 있으며 사용되는 위치에 따라 의미가 달라집니다. 하지만 공통적으로 final 키워드를 쓰면 어떤 것을 변경할 수 없게 만들며 이는 불변성을 확보하기 위한 중요한 수단 중 하나입니다. 
 변수에 사용할 경우 final을 붙이면 해당 변수는 수정 할 수 없습니다. 다만 참조형 변수의 경우 참조하는 객체 내부의 상태정도는 변경 할수있습니다. 
 메소드에 사용할 경우 오버라이드 즉 재정의 하는 것이 불가능 해지기에 이는 안정성을 높이는데 도움이 됩니다. 
 마지막으로 클래스에 사용할 경우 클래스는 상속할 수 없게 만듭니다. 다른 클래스가 final로 선언된 부모클래스를 상속 할 수 없게 합니다.


## 오버로딩(Overloading)과 오버라이딩(Overriding)

---먼저 오버로딩은 같은 이름의 메서드를 한 클래스 내에서 여러가지 정의하는 것을 의미합니다. 이때 메서드는 매개변수의 타입과 개수, 순서가 달라야합니다. 이는 같은 기능을 하는 메서드에 대해 다양한 타입이나 매개변수 수를 가진 데이터를 처리 할수 있게합니다.
다음으로 오버라이딩은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하는 것을 의미합니다. 상위클래스의 메서드를 하위 클래스가 상속받아 사용하되, 하위 클래스의 역할에 맞게 매서드의 동작을 변경하고자 할 때 사용합니다.

## 추상 클래스와 인터페이스

---추상 클래스는 하나 이상의 추상 메서드를 포함하며 인스턴스화 할 수 없는 클래스입니다. 공통적인 기능을 추상 클래스에 정의하고 일부 메서드는 하위 클래스에서 구현하도록 강제하는 데에 목적이 있습니다. abstract keyword를 사용하여 선언하며 일반 메서드도 포함 할 수 있습니다. 다중 상속을 지원하지 않기도합니다. 이때 상속을 통해 하위 클래스에서 추상 메서드를 구현해야 합니다.
 인터페이스는 모든 메서드가 추상 메서드인 순수 추상 클래스입니다. 구현 코드없이 메서드의 시그니처와 기본 필드만을 포하합니다. 서로 다른 클래스들이 구현할 수 있는 공통의 템플릿을 제공하는데 목적이 있습니다. 모든 메서드는 pulic abstract입니다. 또한 추상 클래스와 다르게 다중 구현이 가능합니다.

## JAVA Enum

---자바 enum은 열거형이라고 합니다. 관련된 상수들을 함께 모아 안전한 방식으로 사용 할 수 있게하는 클래스입니다. 이는 가독성을 높이고 오류 가능성을 줄일 수 있습니다. enum이라는 키워드를 사용하여 정의하며 내부에서는 변수와 메서드를 가질 수 있지만, 상속이나 인스턴스 생성은 불가하다는 특징이 있습니다. public static final 한 속성을 가지고 있어 변경할수 없습니다.


## 객체지향

---자바 자체가 객체 지향 프로그래밍 언어로 클래스. 객체, 인스턴스, 상속, 인터페이스, 다형성, 추상화 등 다양한 개념을 포함합니다. 이러한 개념들을 활용하여 코드의 재사용성을 높이고 유지보수를 용이하게 하며 , 대규모 소프트웨어 개발에 적합한 구조를 가집니다. 특히 불필요한 코드를 반복해서 작성할 필요가 없기에 중복을 줄여 시간과 돈을 절약하게 합니다. 


## 객체지향 4대 특성

--첫번째로 캡슐화입니다. 객체의 데이터와 그 데이터를 처리하는 메서드를 하나로 묶는 것을 의미합니다. 두번째로는 상속입니다. 한 클래스가 다른 클래스의 속성과 메서드를 물려받아 사용 할 수 있는 기능입니다. 세번째로는 추상화입니다. 복잡한 실세계를 단순화하여 프로그램이 반영하는 과정입니다. 이는 중요한 정보를 추출하여 정의함으로써 사용자가 복잡한 내부 구현을 몰라도 객체를 사용할수있게합니다. 마지막으로 다형성입니다. 같은 이름의 메서드가 다양한 방식으로 작동할 수 있게 하는 특성입니다. 이는 위의 오버로딩과 오버라이딩으로 구현됩니다.


## SOLID 원칙

---자바의 SOLID 원칙은 객체 지향 프로그래밍 설계에서 중요한 5가지 원칙을 말합니다. 첫번째로 spr(single responsibility principle ) 단일 책임 원칙입니다. 한 클래스는 하나의 책임만을 가져야합니다. 즉 클래스를 변경하는 이유가 단 하나여야 함을 의미합니다. 두번째로 ocp(open,closed principal) 소프트웨어 구성요소(클래스,모듈,메서드등)는 확장에는 열려있어야하고 변경에는 닫혀있어야한다는 특징입니다. 즉 기존의 코드를 변경하지 않으면서 기능을 추가 할수 있어야합니다. 세번째는 lsp (liskov sugregation principle) 서브 타입은 언제나 그것의 베이스 타입으로 교체할 수 있어야 합니다. 즉, 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 프로그램의 정확성이 변하지 않아야 합니다.
ISP (Interface Segregation Principle): 인터페이스 분리 원칙이며 이는 클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안 됩니다.
마지막으로 DIP (Dependency Inversion Principle ):의존관계 역전 원칙입니다.  고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.


# 선택사항 (추가로 공부하면 좋은 것들입니다!)

## Java Annotation

--- 주석과 비슷한 기능입니다. Java Annotation은 @ 기호를 사용하여 선언되며, 컴파일러에게 코드 작성 방법을 알려주거나, 코드 실행 시 특정 동작을 수행하도록 정보를 제공합니다.우리가 흔히 쓰는 @override가 이에 해당됩니다.

## Lambda, Stream

---Lambda 표현식은 간단히 말해 익명 함수(anonymous functions)를 간결한 방식으로 표현할 수 있게 해주는 기능입니다. 메서드를 하나의 식(expression)으로 표현할 수 있으며, 이를 통해 코드의 길이를 줄이고 가독성을 높일 수 있습니다.  예를들어 이벤트 리스너에서의 사용에서 사용됩니다.
 또한 stream API는 데이터 컬렉션 처리를 위한 추상화된 패턴을 제공합니다. 이를 통해 개발자는 데이터를 선언적으로 처리할 수 있으며, 병렬 처리를 쉽게 구현할 수 있습니다. stream의 예시로는 컬렉션의 요소 필터링, 요소들의 매핑등이 있습니다.

## JVM 내부 구조 & 메모리 영역

---jvm의 구조로는 클래스파일들을 런타임 데이터 영역으로 보내는 클래스 로더, 바이트 코드를 실행하게 하는 실행 엔진, 사용하지 않은 객체들을 관리하는 편한 가비지 컬렉터, 데이터들을 관리하는 런타임 데이터 영역 이 있습니다. 
 메모리 영역으로는 클래스 정보, 상수, 정적 변수 등을 저장하는 메서드 영역, 객체와 배열이 할당되는 곳으로, 가비지 컬렉션의 주 대상인 힙 영역,  메서드 호출 시 생성되는 프레임(지역 변수, 부분 결과 등을 저장)을 저장하는 스택 영역, 현재 실행 중인 JVM 명령의 주소를 가지는 PC 레지스터 (Program Counter Register) 자바 외의 언어로 작성된 네이티브 코드를 위한 영역인 네이티브 메서드 스택으로 이루어져있습니다. 
