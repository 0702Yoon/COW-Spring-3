# [1WEEK] JAVA 기본

## COW SPRING 3기 PRE-ONBOARDING 학습 과제

본격적으로 Spring 학습에 들어가기 전에 여러분은 객체지향 코드에 대해 학습하고 이해하는 시간을 가지실겁니다!

객체지향 코드를 짜기 위해서는 우리가 사용할 언어인 JAVA에 대해 이해하고 있어야합니다. 

이 온보딩 과제는 이번 COW L2 - Spring에 함께 하시는 9분의 개개인의 역량이 다르기 때문에 가장 최소한으로 알고 계셔야 할 내용을 중심으로 선정해봤어요!

많은 양의 정리를 요구하지 않는 과제이니 이해하신 내용을 토대로 간단하게 정리해주시면 됩니다. (1, 2기의 학습자료가 github에 나와있으니 참고하셔도 좋아요☺️)

개인적으로, 분명 학습했던걸 다 기억하실 수 없으실거예요! 저도 마찬가지이고요.. 공부했던 것을 잘 정리해두는 습관을 가지는 것은 분명 큰 도움으로 돌아올 것이라 생각합니다. 그런 의미로 다들 파이팅해봐요!

---
> 아래의 필수 질문은 모든 분들이 정리하고 학습하셔야하는 내용입니다. 선택 질문은 원하시는 분들만 하시면 되지만 분명 학습하시면 큰 도움이 될 것들을 추려봤습니다! 

# 필수

## 자바 역사와 버전별 특징

---

자바는 1991년 1월 썬 마이크로 시스템즈의 제임스 고슬링을 비롯한 개발자들과 함께 개발되었다. 현재는 오라클이 선 마이크로 시스템즈를 인수하게 되면서
자바의 관리와 지원을 맡고 있다.기존에는 **오크**(Oak)라 칭했지만, 1996년부터는 **자바**(Java)라는 이름을 사용하기 시작했다.

* JDK 1.0 : 자바의 최초 버전으로 기본적인 자바 언어 기능과 라이브러리를 제공
* JDK 1.1 : 이벤트 리스너, 리플렉션 자바 빈즈 등의 기능이 추가
* Java SE 1.2 : 스윙 GUI 프레임워크와 컬렉션 프레임워크 등이 도입
* Java SE 5 : 제네릭스. 가변인자, 오토박싱/오토언박싱, 향상된 for 문의 기능이 추가
* Java SE 7 : Try-with-Resources 문, 다이아몬드 연산자, 스위치문 에 문자열 사용의 기능이 추가
* Java SE 8 : 람다 표현식, 메서드 참조 스트림 API, 인터페이스 등의 디폴트 메서드와 정적 메서드가 추가
* Java SE 9 : 모듈 시스템이 도입되어, 코드의 재사용성과 유지보수성이 향상
* Java SE 11 : HTTP 클라이언트 API 등의 기능이 추가
* Java SE 17 : 패턴 매칭, sealed 클래스, 인코딩 및 디코딩 API 기능이 추가

## Primitive Type과 Reference Type의 차이점

---

1. `Primitive Type`:

int, double, boolean, char, byte, short, long, float 8가지 데이터 타입으로 이루어져 있다. 스택(stack) 메모리에 값을 직접 저장하며, 메모리 할당과 동시에 값을 가지고 있다. 

2. `Reference Type`:

클래스, 인터페이스, 배열 등과 같은 사용자 정의 데이터 타입이다. 이는 힙(heap) 메모리에 객체를 저장하고, 스택 메모리에는 힙 메모리 내 객체의 참조(주소)를 저장하게 된다.
객체의 실제 값이 아닌 메모리 위치를 가리키는 참조값을 저장하며, 이를 통해 객체에 접근한다. 따라서 원시 타입은 값 자체를 저장하고 스택 메모리에 직접 보관되지만, 참조 타입은 객체의 주소를 저장하고 실제 값은 힙 메모리에 저장되어 진다.

> 1. Null을 포함할 수 있는가?  -   `Primitive Type`은 불가능하지만, `Reference Type`은 가능하다.
> 2. 제너릭 타입에서 사용 가능한가? - `Primitive Type`은 사용할 수 없지만, `Reference Type`은 사용 가능하다.
## JAVA의 접근 제어자

 
접근제어자를 통해 변수, 메서드, 생성자에 대해 외부에서 접근하지 못하도록 설정 가능하다. 접근 제어자로 외부에서 접근하지 못하도록 막으면서 **정보 은닉**이 가능하다는 특징을 지니고 있다.

- 접근 범위 순서 : `public` > `protected` > `default(생략 가능)` > `private`
    - `public` : 내/외부를 포함하여 접근에 제한을 두지 않음
    - `protected` : 동일한 패키지 내 혹은 해당 클래스를 상속받은 클래스에서만 접근 가능
    - `default` : 동일한 패키지 내에서만 접근이 가능 + 생략 가능
    - `private` : 자기 자 클래스 내에서만 접근이 가능


---


## static 키워드

---

`static`은 **정적 멤버**(정적 변수, 정적 메서드)를 정의할 때 사용하며, 메모리를 컴파일 시점에 할당한다. 할당된 메모리는 프로그램이
종료될 때 해체된다. 해당 키워드를 통해 정적 멤버를 생성하면 `Heap 영역`이 아닌 `Static 영역`에 할당된다. 
즉, `GC`의 관리를 받지 못한다.

또한, `static 멤버`의 경우 클래스 레벨에서 공유되어 **객체의 생성없이 접근**할 수 있다는 특징을 가지고 있기에 공유멤버가 필요하거나 전역변수/전역함수로 사용하기 위한 목적으로 사용된다.





## final 키워드

---

final 키워드는 필드, 함수, 클래스에 사용될 수 있다.

* `final 필드` : 값을 할당한 뒤에 수정할 수 없다는 특징을 가지고 있어 초기화는 필수적이다. 
만약, 그렇지 않은 final 필드가 존재할 경우 컴파일 에러가 발생한다.


* `final 함수` : 메서드 오버라이드를 제한하게 된다. final 메소드를 재정의할 경우에 컴파일 오류가 발생한다.


* `final 클래스` : final 키워드를 클래스에 사용할 경우, 상속이 불가능한 클래스가 되어 다른 클래스에서 상속하여 재정의할 수 없게 된다.






## 오버로딩(Overloading)과 오버라이딩(Overriding)

---

1. **오버라이딩** : 상속 관계에서 부모 클래스의 메서드를 동일한 시그니처를 가진 메소드를 자식 클래스에서 재정의하는 것을 뜻한다.
  


2. **오버로딩** : 동일한 이름의 메소드를 매개변수의 타입과 개수가 달리 하여 여러 개의 메소드로  정의하는 것을 뜻한다.


## 추상 클래스와 인터페이스

---

추상 클래스와 인터페이스는 인스턴스화할 수 없으며, 둘 다 추상 메서드를 가지고 있다는 공통점을 가지고 있다.

- **인터페이스**(implements) - "can-do 관계"
: 클래스가 특정 동작을 수행하도록 메서드의 목록으로 정의하며, 인터페이스에서 정의한 모든 메서드를 구현해야 하며, 다중 상속이 가능하다는 점이 특징이다.
  
  - 상속 키워드 : `implements`
  - 사용 가능한 접근 제어자 : `public`

- **추상 클래스**(abstract) - "is-a 관계"
: 하위 클래스가 추상 클래스에서 정의된 메서드를 오버라이딩하여 구체적인 동작을 구현해야 하며, 다중 상속이 불가하고 단일상속이 가능하다.

  - 상속 키워드 : `extends`
  - 사용 가능한 접근 제어자 : 제한 없음

> 추상 클래스는 상속을 통해 공통된 기능을 상속받는 클래스들의 그룹화에 사용되며,   인터페이스는 클래스들이 특정 메서드를 구현하여 클래스들이 목적에 맞게 기능을 구현하는 목적이다.

## JAVA Enum

---

`JAVA Enum`은 Enumeration의 약자로, 열거라는 의미를 가지고 있다. 즉, `Enum`은 연관된 상수 데이터의 집합으로 Enum 타입 클래스를 통해 객체로 표현되어 Heap 메모리에 저장된다는 특징을 가지고 있다.
 
이러한 `Enum`을 사용함으로 코드가 단순해지고 가독성이 좋아지다는 장점이 있으며, 무엇보다 리팩토링을 할 경우에는 코드의 수정의 편리해진다는 점이다. 


## 객체지향

---


: 객체 지향 프로그래밍은 필요로 하는 대상을 데이터로 추상화하여 **상태와 행위를 가진 객체**를 만들고, 그 객체들 간의 유기적인 상호 작용을 통해 로직을 구성하는 프로그래밍 방법론이다.



높은 코드의 재사용성으로 생산성이 향상되어 유지 보수에 유리하지만, 모델링 하는 과정에서 시간이 오래 걸린다는 단점이 있다. 추가로 절차 지향에 비해 실행 속도가 느리다는 점도 있다.  

좋은 객체지향를 설계하기 위해 확장이 가능하도록 인터페이스를 안정적으로 설계해야 하며, 클라이언트에 영향을 주지 않는 선에서 서버의 기능을 구현하고, 변경에 용이하도록 설계하는 것이 중요하다.
또한, 좋은 객체지향을 설계하기 위해 5가지의 원칙을 다형성을 통하여 설계하게 되면 스프링 프레임워크가 제공하는 `DI 컨테이너`를 구현하게 된다. 그렇기에 우리는 스프링 프레임워크를 사용하여 보다 좋은 객체지향 설계를 구현할 수 있게 되는 것이다.

> DI 컨테이너 뿐 아니라 loC 컨테이너 역시 좋은 객체지향 설계를 구현하는 역할을 지니고 있다.
> 
> 여기서 IoC란, 객체의 생성과 관리를 개발자가 아닌 스프링이 관리함으로 비즈니스 로직에 보다 더 집중할 수 있다. 즉, 프로그램의 제어에 관한 흐름을 직접 관리하는 것이 아닌 외부에서 관리하는 것을 
> **제어의 역전(IoC)**라 한다.


## 객체지향 4대 특성

---

- **캡슐화** : 데이터와 해당 데이터를 처리하는 메서드 **하나로 묶어 데이터를 외부로부터 보호**하는 특징을 지닌다.

  ⇒ 이는 `접근 제어자`를 통해 `정보 은닉`을 할 수 있다는  특징을 지니고 있다.


- **추상화** : 객체들의 공통된 특징을 추출하여 이를 하나의 개념이나 클래스로 표현하는 과정이다. 이를 통해 개발자는 객체의 복잡한 내부 동작 방식에 집중하지 않고, 단순히 객체가 제공하는
기능과 속성에 집중할 수 있으며, 상속과 다형성과 함께 재사용성과 높은 유지보수를 기대할 수 있다.


- **상속 :** 클래스 간의 관계를 형성하여 상위 클래스의 속성과 메서드를 하위 클래스가 물려받아 사용할 수 있어 이를 통해 코드의 재사용성과 구조화된 프로그래밍이 가능해진다.


- **다형성 :**  하나의 인터페이스나 메서드가 다양한 방식으로 동작하는 것을 의미한다. 주로 `오버라이딩`, `오버로딩`, `상속` 그리고 `인터페이스`을 통해 구현할 수 있다. 
다형성을 활용하면 동일한 인터페이스에 대해 다양한 구현을 제공할 수 있으며, 프로그램의 유연성을 높일 수 있다.


## SOLID 원칙

---

- **SRP(단일 책임 원칙)** : 클래스는 단 하나의 책임. 즉, 한 가지 기능에 집중할 수 있어야 한다.


- **OCP(개방-폐쇄 원칙)** : 기존 코드 수정없이 기능을 확장할 수 있어야 한다.


- **LSP(리스코프 치환 원칙)** : 자식클래스는 언제나 부모클래스로 대체될 수 있어야 한다.


- **ISP(인터페이스 분리 원칙)** : 클라이언트는 자신에게 불필요한 인터페이스에 의존하지 않아야 한다

 
- **DIP(의존성 역전 원칙)** : 구체적인 구현이 아닌 추상화에 의존해야 한다.

# 선택사항 (추가로 공부하면 좋은 것들입니다!)

## Java Annotation

---

다른 프로그램에게 유용한 정보를 제공하기 위해 사용되는 것으로 주석과 같은 의미를 가진다.
1. 컴파일러에게 문법 에러를 체크하도록 하며, 빌드할 때 코드를 자동으로 생성할 수 있도록 정보를 제공한다. 
2. 런타임에 특정 기능을 실행하도록 정보를 제공하는 역할을 지니고 있다. 
3. `@`을 사용하여 해당 타켓에 대한 동작을 수행하는 프로그램 외 다른 프로그램에게 영향을 주지 않는다.

`Annotation`은 크게 세 가지로 구분된다.

- 표준 Annotation
   
  - `@Override`
  - `@Deprecated`
  - `@FunctionallInterface`
  - `@SuppressWarinings`


- 메타 Annotation

   - `@Target`
   - `@Retention`
   - `@Documented`
   - `@Inherited`


- 사용자 정의 Annotation
  
  

## Lambda, Stream

---

### Lambda란? 

**익명 함수**를 지칭하는 용어로, 자바의 메서드를 간결한 함수 식으로 표현한 것과 같다. 이는 화살표 기호를 넣음으로 코드를 함축시켰다.

``` java
람다의 표현식
1. 매개변수 화살표 (->) 함수몸체로 이용하여 사용할 수 있다.
2. 함수몸체가 단일 실행문이면 괄호{ }를 생략할 수 있다.
3. 함수몸체가 return문으로 구성되어 있는 경우 괄호 { }를 생략할 수 없다.


ind add(int x, int y) {
    return x + y;
}

// 위 메서드를 람다식으로 표현
(int x, int y) -> {
    return x + y;
};

// 매개 변수 타입 생략
(x, y) -> {
    return x + y;
};
```
람다식도 결국 객체이다. 정확히는 함수형 인터페이스를 익명 클래스로 구현한 **익명 구현 객체**를 표현한 것과 같다.
_(※함수형 인터페이스(`@FunctionalInterface`) : 단 하나의 추상 메서드만을 가지는 인터페이스 )_


1. 코드의 간결성으로 불필요한 반복적인 코드를 줄일 수 있다.
2. 멀티 쓰레드를 활용하여 병렬 처리가 가능해진다.
3. 지연연산을 수행함으로 불필요한 연산을 최소화할 수 있다.

### Stream란?

`Lambda`와 같이 자바 8에서 추가된 기술로 람다를 활용하여 배열과 컬렉션을 함수형으로 간단하게 처리할 수 있는 기술이다. 기존 for문과 Iterator를 사용하게 되면
코드가 길어져 가독성과 재사용성이 떨어지는 불편함을 가지고 있었다. 

하지만 `Stream`은 데이터 소스를 추상화하여 데이터를 다루는데 자주 사용되는 메서드를 정의해 놓음으로 코드의 재사용성을 높일 수 있다.
**스트림 인스턴스를 생성**하고 **중간연산**과 **최종연산**을 통한 데이터 소스를 다룰 수 있다.

 1. 스트림 인스턴스 생성
    -  배열 스트림 : `Arrays.stream()`
    -  `Stream.builder()`
    -  람다식 `Stream.generate()`, `iterate()`
    -  기본 타입형 스트림 : `IntStream`, `DoubleStream`, `LongStream`
    -  병렬 스트림: `parallelStream()`


2. 중간 연산

   - Filtering
   - Mapping
   - Sorting

3. 최종 연산

   - Calculating
   - Reduction
   - Collecting
   - Matching
   - Iterating
   - Finding
   


#### 스트림의 특징
1. 데이터 소스를 읽기만 할 뿐, 변경하지 않는다
2. 작업을 내부 반복을 통해 처리함으로 간결하게 해결할 수 있다.
3. `Iterator`와 같이 일회용으로 사용할 수 있다.
4. 멀티 쓰레드를 사용한 병렬 처리가 가능하다.





## JVM 내부 구조 & 메모리 영역

----


: Java Virtual Machine의 약자로, **OS에 종속되지 않고 자바 프로그램이 실행**할 수 있도록 하는 **가상 머신**이다.

1. Java의 원시코드(`*.java`)는 CPU가 인식하지 못하여 기계어로 컴파일해야 한다.
2. Java의 경우, JVM이 인식할 수 있는 Java bytecode(`*.class`)로 변환된다.
3. 이 때, 변환된 Java bytecode(`*.class`)를 **JVM**이 OS가 이해할 수 있도록 해석해주는 역할을 한다.

### 내부 구조 및 메모리 영역

JVM의 구조에는 크게 다음과 같이 나누어져 있다.

1) 클래스 로더 
: JVM 내 Runtime Data Area로 클래스 파일을 로드한다. 동적으로 클래스를 로드하여 클래스를 읽어오는 자바의 경우에는  런타임 시점에 모든 코드가 JVM에 연결되는데 이렇게 동적으로 클래스를 로딩해주는 것이 클래스 로더의 역할이다.

 
 2) 실행 엔진 
: `.class`  파일과 같은 ByteCode를 실행할 수 있도록 해석해준다. 메모리에 적재된 클래스들을 기계어로 번역하여 명령어의 단위로 실행시켜주며 이 때, **인터프리터 방식과 JIT 컴파일러 방식** 두 가지 모두 사용한다.

* 인터프리터 - 바이트 코드 명령어를 하나씩 읽어 해석하고 실행한다. 


* JIT 컴파일러  - 인터프리터 단점을 보완하기 위한 방식으로, 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하여 실행하는 방식으로 전체적인 실행속도는 인터프리터의 방식보다 빠르다.


* 가비지 콜렉터(GC) -  메모리 영역 중 `Heap 영역`에 존재하는 객체들 중에 참조되지 않은 객체들을 제거하는 역할을 가지고 있어 사용하지 않는 메모리를 자동으로 지워준다는 특징을 지니고 있다.
   

 3) 런타임 데이터 영역 
: JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때, 사용되는 데이터를 적재하는 영역이다.
   
    
  *  _Method Area_ : GC의 대상으로, 클래스의 메타데이터의 정보, 정적 변수, 상수 등을 저장하는 공유 영역이다. 모든 쓰레드가 공유하여 JVM이 시작될 때 생성되고, 프로그램이 종료될 때 소멸된다는 특징을 가지고 있다. 


  *  _Heap Area_ : `new 키워드`로 생성된 객체, 인스턴스, 배열 등이 저장되는 공유 메모리 영역이다. Heap 영역은 모든 쓰레드가 공유하며 이 역시 GC의 대상이다. 객체의 동적 할당 및 해제가 이뤄지는 곳으로 크기나 구조가 동적으로 변할 수 있다.


  *  _Stack Area_ : Stack Area는 각 쓰레드마다 별도로 존재하며, 메서드 호출 시 , 지역 변수, 매개변수, 메서드 수행 중에 발생하는 임시 데이터 등을 저장한다. 메서드 호출 시마다 스택 프레임이 생성되어 실행이 완료되면 스택 프레임이 사라진다. 추가로 `LIFO 구조`를 가지고 있다.


  *  _PC Register_ : 현재 수행 중인 JVM 명령의 주소값을 저장하는 곳이다.


  *  _Native Method Stack_ : 자바 프로그램이 네이티브 코드를 호출할 때 사용되는 스택 공간으로, JAVA 외의 다른 언어로 작성된 메서드를 호출할 때 사용된다.


