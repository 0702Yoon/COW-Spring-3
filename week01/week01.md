# [1WEEK] JAVA 기본

## COW SPRING 3기 PRE-ONBOARDING 학습 과제

본격적으로 Spring 학습에 들어가기 전에 여러분은 객체지향 코드에 대해 학습하고 이해하는 시간을 가지실겁니다!

객체지향 코드를 짜기 위해서는 우리가 사용할 언어인 JAVA에 대해 이해하고 있어야합니다.

이 온보딩 과제는 이번 COW L2 - Spring에 함께 하시는 9분의 개개인의 역량이 다르기 때문에 가장 최소한으로 알고 계셔야 할 내용을 중심으로 선정해봤어요!

많은 양의 정리를 요구하지 않는 과제이니 이해하신 내용을 토대로 간단하게 정리해주시면 됩니다. (1, 2기의 학습자료가 github에 나와있으니 참고하셔도 좋아요☺️)

개인적으로, 분명 학습했던걸 다 기억하실 수 없으실거예요! 저도 마찬가지이고요.. 공부했던 것을 잘 정리해두는 습관을 가지는 것은 분명 큰 도움으로 돌아올 것이라 생각합니다. 그런 의미로 다들 파이팅해봐요!

---
> 아래의 필수 질문은 모든 분들이 정리하고 학습하셔야하는 내용입니다. 선택 질문은 원하시는 분들만 하시면 되지만 분명 학습하시면 큰 도움이 될 것들을 추려봤습니다!

# 필수

## 자바 역사와 버전별 특징

### 자바의 역사
자바는 1991년 6월 “선 마이크로시스템즈(Sun Microsystems)”에서 “그린 프로젝트” 라는 이름으로 시작되었으며 해당 프로젝트의 목적은 가전제품에서 사용되는 임베디드 소프트웨어를 만들기 위해서였습니다. 초기에는  “Oak”라는 이름으로 불렸으나, 이미 등록된 상표이기에 1995년에 “자바(Java)”라는 이름으로 바뀌어 공식 출시되었습니다.

자바의 초기 버전은 주로 웹브라우더에서 동작하는 애플릿을 통해 인터넷 상에서 동적인 인터랙션이 가능 하도록 했다. 이후 자바는 서버 사이드, 데스크톱, 모바일 등 다양한 분야 활용 분야로 확장되었습니다. 이후 2010년, 오라클이 선 마이크로시스템즈(Sun Microsystems)를 인수하였으며 현재까지 꾸준히 업데이트 되고 있습니다.

### 자바 버전별 특징

**자바 1**

- JDK1.0(1996년)

  최초의 자바 공식 버전, 기본적인 자바 개발 도구 제공

- JDK1.1(1997년)

  이벤트 모델 개선, 내부 클래스 도입, JavaBeans, JDBC 등이 추가


**자바 2**

- **JDK 1.2 – Java 2 (1998년)**

  **자바 2' 브랜드로 출시, Swing GUI 툴킷 추가, JVM 성능 향상, Collections Framework 도입**

- **JDK 1.3 – Java 2 (2000년)**

  **HotSpot JVM 도입**

- **JDK 1.4 – Java 2 (2002년)**

  **정규 표현식, 입출력(NIO), 로깅 API, XML 처리 등이 추가**


**자바 5**

- JDK 1.5 - Java 5(2004년)

  **제네릭스 도입, 메타데이터(어노테이션), Enum, Varargs, for-each 루프 등의 언어 변경 사항 추가**


**자바 6**

- Java SE 6

  성능 개선, 스크립팅 언어 지원, JDBC 4.0등이 추가


**자바 6**

- **Java SE 6 (2006년)**

  **성능 개선, 스크립팅 언어 지원(JVM 내), JDBC 4.0 등이 추가**


**자바 7**

- **Java SE 7 (2011년)**

  **문자열에서 switch 문 사용 가능, 자동 자원 관리(try-with-resources), 다이아몬드 연산자 (`<>`), NIO.2 파일 시스템 API, Fork/Join 프레임워크 등이 추가**


**자바 8**

- **Java SE 8 (2014년)**

  **람다 표현식, 함수형 인터페이스, 스트림 API, 새로운 날짜/시간 API, 인터페이스의 디폴트 메서드 등이 도입**


**자바 9**

- **Java SE 9 (2017년)**

  **모듈 시스템(JPMS), JShell, HTTP/2 클라이언트, 스트림 API 개선 등이 추가**


**자바 10**

- **Java SE 10 (2018년)**

  **지역 변수 타입 추론(var), 새로운 가비지 컬렉터, 애플리케이션 클래스-데이터 공유 등이 도입**


**자바 11**

- **Java SE 11 (2018년)**

  **HTTP 클라이언트 표준화, 새로운 문자열 메서드, ZGC, Epsilon GC 등이 추가**


**자바 12 ~ 17**

- **Java SE 12 (2019년)**

  **switch 표현식 프리뷰, Shenandoah GC 등이 추가**

- **Java SE 13 (2019년)**

  **텍스트 블록, ZGC 및 Shenandoah의 개선**

- **Java SE 14 (2020년)**

  **switch 표현식(표준), 레코드(프리뷰), 패턴 매칭 instanceof**
---

## Primitive Type과 Reference Type의 차이점
자바의 타입은 크게 Primitive Type(원시 타입)과 Reference Type(참조 타입) 으로 나뉜다.

**Primitive Type(원시 타입)**

Primitive Type은 정수, 실수, 문자, 논리 리터럴 등의 실제 데이터값을 저장 하는 타입입니다.

- int, long, double, float, boolean, byte, short, char 총 8가지로 자바에서 미리 정의 하고 제공합니다
- 사용하기 전에 선언(Declared)되어야 하며, 자료형의 길이는 운영체제에 독립적이며 변하지 않습니다.
- 스택 메모리에 저장됩니다.

**Reference Type(참조 타입)**

객체(Object)를 참조(주소를 저장) 하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입입니다.

- Integer, Long, Double, Float, Boolean, Byte, Short, Char
- 실제 객체는 힙 메모리에 저장되며 **Reference** Type은 스택 메모리에 실제 객체 주소를 저장하여, 객체를 사용 할 때마다 참조변수에 저장된 객체의 주소를 불러와 사용합니다.
- 사용이 끝나면 Garbage Collector가 메모리를 해제합니다.

**Primitive Type과 Reference Type의 차이점**

- Primitive Type은 null을 담을수 없지만 Reference Type은 null을 입력값으로 받을 수 있습니다.

    ```java
    int i = null; // 불가능
    Integer integer = null; // 가능
    ```

- Primitive Type은 제너릭 타입에서 사용할 수 없지만 Reference Type은 제너릭 타입에서 사용 가능 합니다.

    ```java
    List<int> i; // 불가능
    List<Integer> integer; // 가능
    ```
---

## JAVA의 접근 제어자

접근 제어자는 public, protected, default, private로 구성되어 있습니다.

- public : 접근 제한이 없다. 외부로의 노출 또는 외부에서 접근이 모두 가능합니다.
- protected: 동일 패키지와 다른 패키지의 하위 클래스에서 접근 가능합니다.
- default(기본값): 동일 패키지 내에서만 접근 가능합니다.
- private: 동일 클래스에서만 접근이 가능합니다.

접근 제어자를 사용하는 이유는 사용자가 굳이 알 필요 없는 정보를 숨기기 위해 은닉(data hiding)하기 위해서입니다.

---


## static 키워드

static이란 ‘고정된’, ‘공통적인’ 이란 의미를 가지고 있고, 모든 객체가 공유하는 값을 의미합니다.

**자바에서 static은 객체를 생성하지 않고 변수나 메서드를 사용할 수 있게 해줍니다.**

- static은 해당 데이터의 메모리 할당을 컴파일 시간에 할 것임을 의미합니다.
- static 데이터는 프로그램 실행 직후부터 끝날 때까지 메모리 수명이 유지됩니다.
- 인스턴스가 만들어질 때마다 새로운 메모리에 초기화하지 않고, 하나의 메모리 공간만을 사용할 수 있습니다. 이렇게 되면 *인스턴스 생성마다 매번 같은 메모리를 잡지 않아 효율적입니다.*

**static을 사용해야 할때**

- 모든 곳에서 같은 값(하나의 값)으로 상수를 사용하는 경우에는 static으로 선언해야 합니다.
- 클래스를 설계해야할때, 멤버 변수중 모든 인스턴스에 공통적으로 사용하는값에 static을 붙입니다.

---


## final 키워드
final의 사전적 의미는  ‘마지막의‘,  최종적인’이라고 말 할 수 있습니다.

자바 에서 final은 크게 변수, 메서드, 클래스에 사용할 수 있으며 변수에 사용시 ‘재할당’ 이 불가능하고, 메서드에 사용시 ‘오버라이드’ 할 수 없으며, 클래스에 사용시 ‘상속’ 할 수 없게 됩니다.

즉 변하지 않는 상수를 정의할때 사용 할 수 있습니다.

---


## 오버로딩(Overloading)과 오버라이딩(Overriding)
**오버로딩(Overloading)**

오버로딩은 같은 이름의 메서드를 클래스 내부에 여러개 정의하지만, 매개변수의 타입, 개수 또는 순서를 다르게 하여 구분하는 방법으로 클래스 내부에서 메소드를 확장 할 수 있습니다.

```java
public class Dog {
    public void cry() {
        System.out.println("멍멍");
    }

    public void cry(String sound) {
        System.out.println(sound);
    }

    public void cry(String sound, int times) {
        for (int i = 0; i < times; i++) {
            System.out.println(sound);
        }
    }
}
```

**오버라이딩(Overriding)**

상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의 하는 방식으로 오버라이딩된 메서드는 상위클래스의 메서드와 같은 이름, 매개변수, 반환타입을 가져야합니다. 다만 메서드 내용은 다르게 변경할 수 있습니다. 즉 부모 클래스에서 자식클래스로 확장하는 개념입니다.
```java
class Animal {
    public void sound() {
        System.out.println("동물이 운다");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("멍멍");
    }
}
```
---

## 추상 클래스와 인터페이스
**추상클래스**


자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 추상 클래스(abstract class)라고 합니다.

- 하위 클래스의 공통점을 추상화시켜 만든 클래스입니다.
- 다중 상속이 불가능하여 단일 상속만 허용된됩니다.
- 추상화를 하면서 중복되는 클래스 멤버들을 통합시키고 확장시킬 수 있습니다.

**extends 키워드를 사용하여 자신의 기능을 하위 클래스로 확장 시킵니다.**

**인터페이스**

동일한 목적 하 동일한 기능을 하도록 강제 하는 것으로 자바에서 상수와 추상 메서드의 집합입니다.  인터페이스의 추상 메서드를 사용하면 각 클래스들의 변경이 용이합니다.

- 메서드와 필드 모두 public을 사용합니다.
- 클래스에 다중구현을 지원 합니다.
- 인터페이스 끼리 다중상속이 가능합니다.

**implements 키워드를 사용하여 인터페이스에 정의된 메서드들의 기능을 구현클래스에 강제합니다.**

---

## JAVA Enum
enum(Enumeration) 열거형 이라고 하며, 자바에서는 특정 값들의 집합을 정의하는 타입으로 사용됩니다.

주로  연관성있는 상수값들을 정의할때 static final 보다 enum을 사용합니다.

enum을 사용함으로 코드의 가독성을 높이고, 유효하지 않은 값들이 할당되는것을 막아줌으로 코드의 안정성을 높여주는 장점을 가집니다.

enum 정의

```java
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```

**enum 사용**

```java
Day day = Day.MONDAY;
```
---

## 객체지향

**객체지향이란?**

객체지향이란 실세계를 직접적이고 직관적으로 모델링 할 수 있는 패러다임으로 객체지향 프로그래밍은 현실속에 존재하는 현실에 존재하는 사물을 최대한 유사하게 모방해 소프트웨어 내부로 가져오는 작업입니다.

현실 세계는 매우 복잡하기에 객체라는 개념을 이용합니다. 이때 객체란 현실 세계에 존재하는 사물에 대한 추상화입니다. 추상화를 통해서 현실세계의 복잡함을 극복합니다.

**객체지향의 개념**

- 서로 상호작용하는 자율적인 객체들의 공동체입니다.
- 자율적인 객체는 상태와 행위를 가지며 스스로를 책임집니다.
- 각 객체는 협력 하며 정해진 역할을 수행하며 역할은 관련된 책임의 집합입니다.
- 객체끼리는 서로 알 수 없으며, 협력하기 위해 메세지를 전송하며 메세지를 수신받은 객체는 적합한 메서드로 요청을 처리합니다.
---


## 객체지향 4대 특성
1. **캡슐화**
- 특정 객체가 독립적인 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶은 것 입니다.(모듈화)
- 객체안의 정보에 직접 접근을 허용하지 않고 필요에 따라 확인 할 수 있습니다(은닉화).
2. **상속**

   상위 개념의 특징을 하위 개념이 물려 받는 것으로 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념입니다.


3. **추상화**
- 현실에서 출발하되 불필요한 부분을 제거하면서 사물의 본질을 들어나게 하는 과정입니다.
- 공통점은 취하고 차이점은 버리며, 중요한 부분을 강조하고 세부사항을 단순한게 만듭니다. 즉 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념입니다.
- 객체들의 공통적 특징(속성, 기능) 을 모아 하나의 클래스로 다룹니다. 각 객체의 구체적인 개념에 의존하지 않고 추상적 개념에 의존 해야 설계가 유연하게 변경 가능합니다.
4. **다형성**
- 형태가 같은데 다른 기능을 하는 것을 의미합니다.
- 하나의 타입으로 여러가지 참조 변수를 사용 (하나의 객체가 여러가지 타입)합니다.
- 다형성을 활용하면 기능을 확장하거나, 객체를 변경해야할 때 타입 변경 없이 객체 주입만으로 수정이 일어나게 할 수 있습니다.
---


## SOLID 원칙
1. **SRP (Single Responsibility Principle) 단일 책임 원칙**
- 클래스에 역활과 책임을 너무 많이 주면안됩니다. 그렇기에 모든 클래스는 각각 하나의 책임을 가져야합니다.
- SRP 원칙을 지키면 기능 변경(수정)' 이 일어났을때  유연하게 대처가능합니다.
2. **OCP (Open Closed Principle) 개방 폐쇄 원칙**
- 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 합니다.
- 클래스를 확장하여 구현하고 확장에 따른 클래스의 수정은 최소화 해야합니다
- 캐릭터를 하나 생성한다고 할때, 각각의 캐릭터가 움직임이 다를 경우 움직임의 패턴 구현을 하위 클래스에 맡긴다면 캐릭터 클래스의 수정은 필요가 없고(Closed) 움직임의 패턴만 재정의 합니다.(Open)

3. **LSP (Liskov Substitution Principle) 리스코프 치환 원칙**
- 하위클래스가 상위클래스 역할을 대신할 때 논리적으로 맞아 떨어져야 합니다.

4. **ISP (Interface Segregation Principle) 인터페이스 분리 원칙**
- 한 클래스는 자신이 사용하지않는 인터페이스는 구현해서는 안됩니다.
- 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 합니다. 즉 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 합니다.
- 인터페이스를 각각 사용에 맞게 끔 잘 분리해야합니다.

5. **DIP (Dependency Inversion Principle) 의존 역전 원칙**
- 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존해야 합니다.
- 클래스를 직접 참조하는 것이 아니라 그대상의 상위 요소(추상 클래스 or 인터페이스)로 참조해야합니다.
---


# 선택사항 (추가로 공부하면 좋은 것들입니다!)

## Java Annotation
Java Annotation은 Java 5부터 추가된 기능으로, 메타 데이터 형태로 코드에 추가정보를 제공하는 방법입니다.

Java의 Annotation은 보통 “@” 기호를 앞에 붙여 생성합니다.

**Java Annotation을 사용시 이점**

- 컴파일러에게 코드 문법 에러를 체크할 수 있도록 정보를 제공합니다.
- 소프트웨어 개발 환경 빌드시 코드를 자동으로 생성할 수 있도록 정보를 제공합니다.
- 런타임에 특정 기능을 실행하도록 정보를 제공합니다.

**빌트인 어노테이션**

- @Override : 메소드를 오버라이드 하겠다는 의미로 메소드 선언시 앞에 붙여줍니다. 만약 상속 받은 부모 클래스나 구현해야할 인터페이스에 해당 메소드가 없으면 컴파일 오류가 발생합니다.
- @Deprecated  : 해당 메소드를 사용하는 애플리케이션을 컴파일 할경우 컴파일경고가 발생합니다.
- @SuppressWarnings: 컴파일러 경고를 출력하지 않도록 설정합니다.
- @SafeVarargs: 재너릭 가변인자 매개변수를 사용할떄 경고를 무시합니다.
- @Functionallnterface: 자바에서 람다 함수를 위한 인터페이스를 지정합니다. 함수형 인터페이스에 사용이 부적합할때 컴파일 오류가 발생합니다.

**메타 어노테이션**

- @Target: 어노테이션이 적용될 수 있는 Java 요소를 지정합니다(예: 메소드, 필드 등).
  @Retention: 어노테이션이 어느 시점까지 유지될 것인지를 지정합니다(예: 소스 코드, 클래스 파일, 런타임).
  @Documented: 어노테이션이 JavaDoc 문서에 포함될 것인지를 나타냅니다.
  @Inherited: 어노테이션이 하위 클래스에 상속될 것인지를 나타냅니다.
  @Repeatable: 어노테이션을 한 요소에 여러 번 적용할 수 있게 합니다.
---

## Lambda, Stream
**Lambda(람다)**

람다식이란 메서드를 하나의 식으로 표현하는 것입니다. 즉 메서드를 변수처럼 다루는 것이 가능합니다. 람다식으로 표현하게 되면 간략하게 표현이 가능하게 되며, 메서드의 이름과 반환값이 없어져 익명함수라고도 불립니다.

**람다식으로 변환하는 방법**

1. 반환 값이 있는 경우 return 문을 생략후 식으로 대신합니다
2. 식의 끝에는 세미콜론(;)을 붙이지 않습니다.
3. 선언된 매개변수의 타입 또한 생략이 가능합니다.

**메서드**

```java
public int sum(int a, int b) {
    return a + b;
}
```

**람다식**

```java
(a, b) -> a + b
```

**Stream**

선언형으로 컬렉션 데이터를 처리해주도록 해줍니다. 데이터 컬렉션 요소를 함수형 스타일로 처리할 수 있게 해주며, 이를 통해 간결하고 가독성 높은 코드를 작성할 수 있습니다.

**스트림의 특징**

- 비순차적 처리: 데이터를 비순차적으로 처리할 수 있어 병렬 실행을 쉽게 할 수 있습니다.
- 내부 반복: 내부반복을 통해 반복 처리를 추상화하고처리를 스트림 라이브러리에 위임 합니다.
- 한 번 사용: 스트림은 재사용이 불가능합니다.

**스트림의 연산**

- 중간 연산: 스트림을 변환하는 연산입니다. 필터링(filtering), 매핑(mapping), 정렬(sorting) 등이 있으며, 중간 연산은 스트림을 반환하고 연속적인 연결이 가능합니다.
- 종단 연산: 스트림 처리를 완료하고 결과를 반환하는 연산입니다. 집계(aggregation), 카운트(counting), 반복(foreach) 등이 있으며, 종단 연산을 수행한 후에는 스트림의 재사용이 불가능합니다.
---

## JVM 내부 구조 & 메모리 영역
JVM은 java virtual machin(자바 가상 머신)으로 자바 애플리케이션을 클래스로더를 통해 읽어들여 자바 API와 함께 실행합니다. JAVA와 OS사이에 중개자 역할을 해서 OS에 구애받지 않고 독립적인 작동이 가능하게 해줍니다.

**JVM의 내부 구조**

- Class Loader: 클래스 파일을 runtime data Area의 메서드 영역으로 불러오는 역할을 합니다.
- Execution Engine: 클래스 파일과 같은 ByteCode를 실행 가능 하도록 해석합니다.
- GC: 메모리 관리 기법, HEAP영역에 배치된 객체를 관리 합니다.
- Runtime Data Area: 런타임시 클래스 데이터와 같은 메타 데이터와 실제 데이터 저장되는 곳으로 프로그램을 수행하기 위해 os로 부터 할당 받은 메모리 공간입니다.

**JVM메모리 영역**

- PC Register

  jvm은 스택 기반 가상머신으로, CPU에 직접 접근하지 않고 스택에서 주소 뽑아 사용 후 PC에 저장합니다.

- JVM Stack

  호출된 메서드의 파라미터, 지역변수,리턴값, 연산값이 저장되는 영역으로, 프로그램 실행 시 임시 할당,  메서드를 빠져나가면 소멸되는 특성의 데이터를 저장합니다.

  메서드 호출시 스택에 각각의 스택 프레임이 생성되고, 수행이 끝나면 프레임 제거합니다.

- Native Method Stack

  java 이외의 언어에 제공되는 메서드의 정보를 저장합니다.

- Heap

  GC의 대상이되는 영역입니다.

  객체를 동적 생성하면 인스턴스가  힙의 메모리에 할당됩니다.

  레퍼렌스 변수는 포인터가 저장합니다.

